---
layout: page
title: "סיכום מקיף: יסודות התכנות ב-C# - חלקים א' וב'"
subtitle: "מדריך שלם הכולל תנאים, לולאות, פונקציות, מחרוזות ומערכים"
author: "גיא סידס"
---

{: .box-note}
**סיכום זה מרכז את הידע שנרכש בחלקים א' וב' של הקורס ומהווה הכנה לקראת חלק ג'.**

בחלקים אלו למדנו את אבני הבניין של מדעי המחשב: החל מקבלת החלטות לוגיות, דרך אוטומציה של פעולות באמצעות לולאות, ועד לארגון קוד מתקדם בפונקציות ושימוש במבני נתונים. 

**מה צפוי בחלק ג':**
- **מערכים דו-ממדיים:** עבודה עם מטריצות וטבלאות נתונים.
- **עצמים ומחלקות (OOP):** תכנות מונחה עצמים, הגדרת מחלקות, תכונות ופעולות.
- **פתרון בגרויות:** הכנה ממוקדת לשאלונים 381 ו-371.

**קישורים לסרטוני ההדרכה:**
- [פלייליסט חלק א'](https://www.youtube.com/playlist?list=PLnVUJu2KuoA04DlduroHvjZfhbxagO9nP)
- [פלייליסט חלק ב'](https://www.youtube.com/playlist?list=PLnVUJu2KuoA0igr7xHclrzS2O7bBaqg2S)

---

## פרק 3 - תנאים, ביטויים לוגיים ושארית חלוקה {#chapter3}
{: .box-note}
**בפרק זה נלמד כיצד לקבל החלטות בתוכנית שלנו באמצעות תנאים, ביטויים לוגיים ושימוש בשארית החלוקה [1].**

<details open markdown="1">
<summary><b>3.1 משפטי תנאי (if, else, else if)</b></summary>

משפט תנאי מאפשר לבצע פקודות רק אם ביטוי לוגי מסוים מחזיר `true` [2].
- **if פשוט:** בדיקת תנאי יחיד.
- **if-else:** ביצוע פעולה חלופית אם התנאי לא התקיים [3].
- **else if:** בדיקת מספר אפשרויות בשרשרת, כאשר לכל היותר אחת תתבצע [4, 5].

**אזהרה:** יש להשתמש ב-`==` להשוואה. שגיאה נפוצה היא הוספת `;` בסוף שורת ה-`if`, מה שיגרום לגוף התנאי להתבצע תמיד [5, 6].

[למידע נוסף על מבנה התנאים](/cs/Chapter3/#id3if)
</details>

<details markdown="1">
<summary><b>3.2 אופרטורים לוגיים ושארית חלוקה (%)</b></summary>

האופרטורים מאפשרים השוואה ושילוב תנאים [7]:
- `&&` (AND): שני התנאים חייבים להתקיים.
- `||` (OR): לפחות אחד התנאים חייב להתקיים.
- `!` (NOT): שלילת הערך הלוגי.
- `%` (מודולו): מחזיר את שארית החלוקה. שימושי לזיהוי זוגיות (`num % 2 == 0`) או בידוד ספרות [8].

[טבלת אופרטורים מלאה](/cs/Chapter3/#id3ops)
</details>

<details markdown="1">
<summary><b>3.3 משתני דגל וטבלאות מעקב</b></summary>

**משתנה דגל (Flag):** משתנה בוליאני השומר מצב (למשל, האם נמצא מספר מסוים) [9].
**טבלת מעקב:** כלי לרישום שינויי משתנים על נייר כדי להבין את זרימת הקוד [5].

**דוגמה למעקב פלינדרום (עבור הקלט 363):** [5, 10]
| שורה | num | units | hundreds | units == hundreds | פלט |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 3 | 363 | 3 | - | - | - |
| 4 | 363 | 3 | 3 | - | - |
| 5 | 363 | 3 | 3 | **true** | 363 is a palindrome |

[דוגמאות מעקב נוספות](/cs/Chapter3/#id3palindrome)
</details>

---

## פרק 4 - לולאות for {#chapter4}
{: .box-note}
**לולאת for משמשת לביצוע פעולה מספר מוגדר של פעמים [11].**

<details open markdown="1">
<summary><b>4.1 מבנה הלולאה ושימושים</b></summary>

המבנה כולל: איתחול מונה, תנאי עצירה וקידום המונה [11].
**שימושים נפוצים:**
- **צובר (Sum):** חישוב סכום מספרים בתוך הלולאה [12].
- **מציאת מקסימום/מינימום:** השוואת כל קלט למשתנה השומר את הערך הגבוה ביותר שנמצא עד כה [13].

{% highlight cs %}
int max = -1;
for (int i = 0; i < 10; i++) {
    int num = int.Parse(Console.ReadLine());
    if (num > max) max = num;
}
{% endhighlight %}

[סרטון הסבר לולאות for](/cs/Chapter4/#id4video)
</details>

<details markdown="1">
<summary><b>4.2 טכניקת הגילגול (Sliding Window)</b></summary>

שימוש במשתנה עזר (לרוב `prev`) כדי לשמור את הערך מהאיטרציה הקודמת. טכניקה זו חיונית לספירת שינויים ברצף או השוואת איברים סמוכים [14, 15].

[תרגול גילגול והיסטוריה](/cs/Chapter4/#id4sliding)
</details>

---

## פרק 5 - לולאות while {#chapter5}
{: .box-note}
**לולאת while מתבצעת כל עוד תנאי מסוים מתקיים, ומתאימה למצבים בהם מספר החזרות אינו ידוע מראש [16, 17].**

<details open markdown="1">
<summary><b>5.1 עבודה עם זקיפים וקלט</b></summary>

- **זקיף (Sentinel):** ערך מוסכם (כמו 0) המורה על הפסקת קליטת הנתונים [18].
- **קלט כפול:** קליטה ראשונה לפני הלולאה וקליטה נוספת בסוף גוף הלולאה כדי לעדכן את התנאי [19].
- **שימוש ב-break:** מאפשר יציאה מיידית. מומלץ כשהוא משפר את הקריאות, אך יש להימנע ממנו בתוך מבנים מסובכים מדי [20, 21].

[השוואה בין דרכי מימוש לולאות](/cs/Chapter5/#id5compare)
</details>

<details markdown="1">
<summary><b>5.2 אלגוריתמים עם ספרות (פירוק ובנייה)</b></summary>

- **פירוק מספר:** שימוש ב-`% 10` לקבלת ספרה ימנית ו-`/ 10` להסרתה [22].
- **הפיכת מספר:** בניית מספר חדש ע"י הכפלה ב-10 והוספת הספרה שחולצה [23, 24].

[קוד מלא להפיכת מספר](/cs/Chapter5/#id5reverse)
</details>

---

## פרק 6 - לולאות מקוננות {#chapter6}
{: .box-note}
**קינון (Nesting) הוא מצב בו לולאה אחת נמצאת בתוך גוף לולאה אחרת [25, 26].**

<details markdown="1">
<summary><b>6.1 יתרונות וחסרונות</b></summary>

- **יתרונות:** מאפשר טיפול במבנים היררכיים, מטריצות ודגמים [27].
- **חסרונות:** פגיעה בביצועים (זמן ריצה גדל משמעותית) וסיבוך הקריאות [28].
- **כלל אצבע:** מומלץ לא לחרוג מ-2 עד 3 רמות קינון [28].

[מורכבות וביצועים בקינון](/cs2/Chapter6/#id6nesting)
</details>

<details open markdown="1">
<summary><b>6.2 תבניות גרפיות (Patterns)</b></summary>

לולאות מקוננות הן הכלי המרכזי להדפסת דגמים (כוכביות, מספרים) [29].
- **חיצונית:** אחראית על השורות.
- **פנימית:** אחראית על התוכן בכל שורה (עמודות) [30].

[תרגול Patterns עם פתרונות](/cs2/Chapter6/#id6patterns)
</details>

---

## פרק 7 - פונקציות (פעולות) {#chapter7}
{: .box-note}
**פונקציות מחלקות את התוכנית לתתי-משימות, משפרות קריאות ומאפשרות שימוש חוזר בקוד (DRY) [31, 32].**

<details open markdown="1">
<summary><b>7.1 הגדרת פונקציה וחתימה</b></summary>

הגדרת פונקציה כוללת [33]:
- **מודיפייר:** `static` (בשלב זה).
- **סוג החזרה:** `void` (ללא החזרה) או סוג נתונים (כמו `int`, `bool`).
- **שם:** בשיטת `PascalCase`.
- **פרמטרים:** משתני הקלט שהפונקציה מצפה לקבל [34].

[חתימה לעומת הגדרה](/cs2/Chapter7Full/#id7syntax)
</details>

<details markdown="1">
<summary><b>7.2 העברת פרמטרים וערכי החזרה</b></summary>

- **ארגומנט:** הערך המועבר בפועל בזמן הקריאה [34].
- **העברה לפי ערך:** הפונקציה מקבלת **עותק** של הנתון, ולכן שינוי שלו בתוך הפונקציה לא ישפיע מחוצה לה [35].
- **מילת המפתח ref:** מאפשרת לשנות את המשתנה המקורי (לא בתוכנית הלימוד הבסיסית אך חשוב להבנה) [36].
- **החזרת ערך (return):** מאפשרת "לשלוח" תוצאה חזרה למקום שקרא לפונקציה [37, 38].

[שרשור פעולות וערכי החזרה](/cs2/Chapter7Full/#id7.3)
</details>

---

## פרק 8 - מחרוזות (Strings) {#chapter8}
{: .box-note}
**מחרוזת היא אוסף תווים המתנהגת לצרכי קריאה כמו מערך, אך היא Immutable [39, 40].**

<details markdown="1">
<summary><b>8.1 תכונות ופעולות בסיסיות</b></summary>

- **Immutable:** לא ניתן לשנות תו בודד בתוך מחרוזת קיימת; כל שינוי יוצר מחרוזת חדשה [40].
- **פעולות נדרשות:** גישה לפי אינדקס `[i]`, אורך `.Length`, בדיקת הכלה `.Contains` ומציאת מיקום `.IndexOf` [39].
- **השוואה לקסיקוגרפית:** השוואת מחרוזות לפי סדר ה-ABC [41].

[מדריך מחרוזות מלא](/cs2/Chapter8/#id8strings)
</details>

---

## פרק 9 - מערכים חד-ממדיים {#chapter9}
{: .box-note}
**מערך הוא אוסף משתנים מאותו סוג השמורים תחת שם אחד [42, 43].**

<details open markdown="1">
<summary><b>9.1 יסודות המערך וסריקה</b></summary>

- **גישה:** באמצעות אינדקס (החל מ-0 עד `Length - 1`) [42].
- **לולאת foreach:** דרך קריאה ונוחה לסרוק את כל איברי המערך ללא ניהול ידני של המונה [42, 43].
- **איתחול ישיר:** ניתן לאתחל מערך עם ערכים בתוך סוגריים מסולסלים `{}` [42].

[מעבר לפרק מערכים](/cs2/Chapter9a/#id9basics)
</details>

<details markdown="1">
<summary><b>9.2 סוגי מערכים מתקדמים</b></summary>

- **מערך מונים:** מערך בו האינדקס מייצג ערך, והתוכן מייצג את מספר הופעותיו [43].
- **מערך דגלים (מציינים):** מערך בוליאני המציין קיום של תנאי עבור כל אינדקס [44].
- **מערך צוברים (Prefix Sum):** שמירת סכום מצטבר המאפשר חישוב סכומי טווחים במהירות [45].

[הסבר על מערך מונים וצוברים](/cs2/Chapter9c/#id9counters)
</details>

<details open markdown="1">
<summary><b>9.3 הכנה לבגרויות - מערכים</b></summary>

עמוד **9Ex9.3** מרכז שאלות בגרות שאינן דורשות ידע בעצמים:
- **שאלון 371:** שאלות מעקב, סיסמאות והצפנה [46].
- **שאלון 381:** סכומים מקסימליים, מערכי הפרשים ומערכים ממוינים [47].

[קישורים ישירים לשאלות בגרות](/cs2/Chapter9Ex9.3/#id9exams)
</details>

---

**סוף הסיכום.**
*אנלוגיה לסיום: תכנות הוא כמו בנייה בקוביות; הפרקים הראשונים הם הקוביות הבסיסיות (תנאים ולולאות), והפרקים המתקדמים הם הוראות ההרכבה (פונקציות ומערכים) המאפשרות לבנות מבנים מורכבים ומרשימים.*
